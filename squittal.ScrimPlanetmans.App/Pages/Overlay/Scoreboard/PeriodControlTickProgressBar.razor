@using squittal.ScrimPlanetmans.App.Pages.Shared;
@using squittal.ScrimPlanetmans.Models;
@using squittal.ScrimPlanetmans.ScrimMatch;
@using squittal.ScrimPlanetmans.ScrimMatch.Messages;
@using squittal.ScrimPlanetmans.ScrimMatch.Models;
@using squittal.ScrimPlanetmans.ScrimMatch.Timers;
@using squittal.ScrimPlanetmans.Services.Planetside;
@using squittal.ScrimPlanetmans.Services.ScrimMatch;
@using System.Threading;

@inject IScrimMatchEngine ScrimMatchEngine
@inject IScrimTeamsManager ScrimTeamsManager
@inject IScrimMessageBroadcastService MessageService
@inject IFactionService FactionService
@inject IOverlayStateService OverlayState 

@implements IDisposable


@if ((MatchState == MatchState.Running || MatchState == MatchState.Paused) && _showComponent)
{
    <div class="periodic-control-progress-container">
        @*<div class="tick-bar left"></div><div class="tick-bar right"></div>*@
        @*<div class="tick-bar left" style="transform: scaleX(@_scaleValue); animation: none; transition: transform 0.25s linear;"></div><div class="tick-bar right" style="transform: scaleX(@_scaleValue); animation: none; transition: transform 0.25s linear;"></div>*@
        <div class="tick-bar left" style="transform: scaleX(@_scaleValue);"></div><div class="tick-bar right" style="transform: scaleX(@_scaleValue);"></div>
        <div class="legend-container @SqCssHelper.GetFactionClassFromId(_controllingFactionId)">
            <span class="points @SqCssHelper.GetFactionClassFromId(_controllingFactionId)">+@PointsPerTick</span>
            <span class="flag capture-flag-container @SqCssHelper.GetFactionClassFromId(_controllingFactionId)">
                @*<span class="iconify capture-flag" data-icon="ion:flag" data-inline="false" style="color: var(--sq-ov-bg-dark-gray-alpha-90); font-size: 12px; filter: drop-shadow(-1px 0px 1px var(--sq-black)); margin-top: -10px; margin-left: 1px; color: var(--sq-ov-ps2-primary);"></span>*@
                <span class="iconify capture-flag" data-icon="ion:flag" data-inline="false"></span>
            </span>
        </div>
        @*<p style="color: black;">@GetUpdateDelayMilliseconds()</p>
        <p style="color: black;">@GetMillisecondsElapsedFromLastPeriodicTick()</p>
        <p style="color: black;">@((int)(DateTime.UtcNow - _lastUpdateTime.Value).TotalMilliseconds)</p>*@

        @*<p style="color: black;">@SecondsPerTick</p>
        <p style="color: black;">@_msSinceLastTick</p>*@
        @*<p style="color: black;">_alreadySubbed: @_alreadySubbed</p>
        <p style="color: black;">_instanceGuid: @_instanceGuid</p>*@
    </div>
}
@*<p style="color: black;">@_controllingTeamOrdinal</p>
<p style="color: black;">@_controllingFactionId</p>
<p style="color: black;">@(Enum.GetName(typeof(MatchState), MatchState))</p>
<p style="color: black;">@_showComponent</p>
<p style="color: black;">@_lastUpdateTime</p>*@

@code {
    //[Parameter]
    //public MatchState MatchState { get; set; }
    //private MatchState _renderedMatchState { get; set; } = MatchState.Uninitialized;

    //[Parameter]
    //public int PointsPerTick { get; set; }
    ////public int _renderedPointsPerTick { get; set; }

    //[Parameter]
    //public int SecondsPerTick { get; set; }
    ////public int _renderedSecondsPerTick { get; set; }

    private MatchState MatchState { get; set; }
    private bool IsPeriodPointsEnabled { get; set; } = false;
    private int SecondsPerTick { get; set; }
    private int PointsPerTick { get; set; }

    private bool _showComponent { get; set; } = false;

    private bool _alreadySubbed { get; set; } = false;

    //private bool _isPeriodicControlTicksEnabled { get; set; } = false;
    //private int? _periodicControlTickInterval { get; set; }
    //private int? _periodicControlTickPoints { get; set; }
    private int? _controllingTeamOrdinal { get; set; }
    private int? _controllingFactionId { get; set; }

    private MatchTimerTickMessage _latestTimerTickMessage;
    private PeriodicPointsTimerStateMessage _latestPeriodicPointsTimerTickMessage;
    private PeriodicPointsTimerStateMessage _latestElapsedPeriodicPointsTimerTickMessage;
    private ScrimFacilityControlActionEventMessage _latestFacilityControlMessage;

    private Guid lastReceivedGuid { get; set; }

    private Timer _updateTimer { get; set; }
    private int _updateTimerPeriod = 1000;
    private DateTime? _lastUpdateTime { get; set; }
    private int _resumeDelayMs { get; set; }
    private readonly AutoResetEvent _autoEvent = new AutoResetEvent(true);

    private readonly AutoResetEvent _msgAutoEvent = new AutoResetEvent(true);
    private bool _disposed = false;

    private int _msSinceLastTick { get; set; }
    private double _scaleValue { get; set; }
    //private LocalStatefulTimer _updateTimer { get; set; }

    private DateTime? LastElapsedTime => _latestPeriodicPointsTimerTickMessage == null ? null : _latestPeriodicPointsTimerTickMessage.LastElapsedTime;
    private DateTime? LastPausedTime  => _latestPeriodicPointsTimerTickMessage == null ? null : _latestPeriodicPointsTimerTickMessage.LastPausedTime;
    private DateTime? LastResumedTime  => _latestPeriodicPointsTimerTickMessage == null ? null : _latestPeriodicPointsTimerTickMessage.LastResumedTime;

    private Guid _instanceGuid;

    //private readonly KeyedSemaphoreSlim _periodicMsgLock = new KeyedSemaphoreSlim();
    private static SemaphoreSlim _periodicMsgLock; // = new SemaphoreSlim(0, 1);

    #region Initialization
    protected override void OnInitialized()
    {
        // ~~FIRST: determine whether the component should be displayed~~

        // ~~Always subscribe to this~~
        //MessageService.RaiseMatchConfigurationUpdateEvent += ReceiveMatchConfigurationUpdateEvent;

        //Dispose();
        //_disposed = false;
        //_updateTimer?.Dispose();
        //MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
        ////MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
        //MessageService.RaiseScrimFacilityControlActionEvent -= ReceiveFacilityControlEvent;
        //MessageService.RaiseMatchStateUpdateEvent -= ReceiveMatchStateUpdateEvent;

        ////MessageService.RaisePeriodicPointsTimerTickEvent += ReceivePeriodicPointsTimerTickEvent;
        ////MessageService.RaiseScrimFacilityControlActionEvent += ReceiveFacilityControlEvent;
        ////MessageService.RaiseMatchStateUpdateEvent += ReceiveMatchStateUpdateEvent;

        _instanceGuid = Guid.NewGuid();
        OverlayState.SetActivePeriodicPointsProgressBarGuid(_instanceGuid);

        _periodicMsgLock = new SemaphoreSlim(1, 1);

        SyncMatchStateAndConfig();

        //var latestPeriodicTickTime = _latestPeriodicPointsTimerTickMessage.Timestamp;
        //var currentTime = DateTime.UtcNow;

        //_updateTimer = new LocalStatefulTimer(HandleUpdateTimerTick, _updateTimerPeriod);
        Console.WriteLine($"======= OnInitialized ({_instanceGuid}) =======");
        Console.WriteLine($"  {OverlayState.GetActivePeriodicPointsProgressBarGuid()}");
        var resumeDelay = GetUpdateDelayMilliseconds();
        Console.WriteLine($"  resumeDelay = {resumeDelay}");

        //_updateTimer = new Timer(HandleUpdateTimerTick, _autoEvent, Timeout.Infinite, 1000);
        _updateTimer = new Timer(HandleUpdateTimerTick, _autoEvent, resumeDelay, _updateTimerPeriod);

        SyncProgressState();

        if (!_alreadySubbed)
        {
            //MessageService.RaisePeriodicPointsTimerTickEvent += ReceivePeriodicPointsTimerTickEvent;
            //MessageService.RaiseScrimFacilityControlActionEvent += ReceiveFacilityControlEvent;
            //MessageService.RaiseMatchStateUpdateEvent += ReceiveMatchStateUpdateEvent;
        }

        _alreadySubbed = true;
    }

    protected override void OnAfterRender(bool firstRender)
    {

        if (firstRender)
        {
            Console.WriteLine($"======= OnAfterRender({firstRender}) ({_instanceGuid}) =======");
            Console.WriteLine($"  {OverlayState.GetActivePeriodicPointsProgressBarGuid()}");

            MessageService.RaisePeriodicPointsTimerTickEvent += ReceivePeriodicPointsTimerTickEvent;
            MessageService.RaiseScrimFacilityControlActionEvent += ReceiveFacilityControlEvent;
            MessageService.RaiseMatchStateUpdateEvent += ReceiveMatchStateUpdateEvent;

            _alreadySubbed = true;
        }
    }

    //protected override void OnParametersSet()
    //{
    //    Console.WriteLine("======= OnParametersSet =======");
    //    Console.WriteLine($"Param MatchState: {Enum.GetName(typeof(MatchState), MatchState)}");
    //    Console.WriteLine($"_renderedMatchState: {Enum.GetName(typeof(MatchState), _renderedMatchState)}");

    //    if (MatchState == MatchState.Stopped || MatchState == MatchState.Uninitialized)
    //    {
    //        _renderedMatchState = MatchState;

    //        _controllingTeamOrdinal = null;
    //        _latestFacilityControlMessage = null;
    //        _latestPeriodicPointsTimerTickMessage = null;
    //        _latestTimerTickMessage = null;

    //        _lastUpdateTime = null;

    //        _controllingTeamOrdinal = null;
    //        _controllingFactionId = null;

    //        _showComponent = false;
    //    }
    //    else if (PointsPerTick <= 0 || SecondsPerTick <= 0)
    //    {
    //        _showComponent = false;
    //    }
    //    else if (MatchState != _renderedMatchState)
    //    {
    //        Console.WriteLine($"MatchState: {Enum.GetName(typeof(MatchState), _renderedMatchState)} => {Enum.GetName(typeof(MatchState), MatchState)}");

    //        _renderedMatchState = MatchState;

    //        _showComponent = true;

    //        //var resumeDelay = GetUpdateDelayMilliseconds();
    //        //Console.WriteLine($"resumeDelay = {resumeDelay}");

    //        ////_updateTimer = new Timer(HandleUpdateTimerTick, _autoEvent, resumeDelay, _updateTimerPeriod);

    //        //_updateTimer.Change(resumeDelay, _updateTimerPeriod);

    //        //SyncProgressState();
    //    }
    //    //InvokeAsyncStateHasChanged();
    //}

    public void Dispose()
    {
        Console.WriteLine($"======= OnDispose ({_instanceGuid}) =======");
        Console.WriteLine($"  {OverlayState.GetActivePeriodicPointsProgressBarGuid()}");
        _updateTimer?.Dispose();

        _msgAutoEvent.Set();

        _periodicMsgLock?.Dispose();

        //MessageService.RaiseMatchTimerTickEvent -= ReceiveMatchTimerTickEvent;
        MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
        MessageService.RaiseScrimFacilityControlActionEvent -= ReceiveFacilityControlEvent;
        MessageService.RaiseMatchStateUpdateEvent -= ReceiveMatchStateUpdateEvent;

        _disposed = true;
    }

    private void SyncMatchStateAndConfig()
    {
        MatchState = ScrimMatchEngine.GetMatchState();

        IsPeriodPointsEnabled = ScrimMatchEngine.MatchConfiguration.EnablePeriodicFacilityControlRewards;
        SecondsPerTick = ScrimMatchEngine.MatchConfiguration.PeriodicFacilityControlIntervalNonNullable;
        PointsPerTick = ScrimMatchEngine.MatchConfiguration.PeriodicFacilityControlPointsNonNullable;

        if (MatchState == MatchState.Stopped || MatchState == MatchState.Uninitialized || !IsPeriodPointsEnabled)
        {
            _controllingTeamOrdinal = null;
            _latestFacilityControlMessage = null;
            _latestPeriodicPointsTimerTickMessage = null;
            _latestTimerTickMessage = null;

            _lastUpdateTime = null;

            _controllingTeamOrdinal = null;
            _controllingFactionId = null;

            //_updateTimer?.Dispose();
            _updateTimer.Change(Timeout.Infinite, Timeout.Infinite);

            _showComponent = false;
        }
        else
        {
            _latestTimerTickMessage = ScrimMatchEngine.GetLatestTimerTickMessage();
            _latestPeriodicPointsTimerTickMessage = ScrimMatchEngine.GetLatestPeriodicPointsTimerTickMessage();
            _latestFacilityControlMessage = ScrimMatchEngine.GetLatestFacilityControlMessage();

            _controllingTeamOrdinal = ScrimMatchEngine.GetFacilityControlTeamOrdinal();

            if (_controllingTeamOrdinal.HasValue)
            {
                _controllingFactionId = ScrimTeamsManager.GetTeam(_controllingTeamOrdinal.Value).FactionId;
            }

            if (_controllingFactionId.HasValue)
            {
                _showComponent = true;
            }
            else
            {
                _showComponent = false;
            }

            if (_updateTimer == null)
            {
                Console.WriteLine($"======= SyncMatchStateAndConfig ({_instanceGuid})  =======");
                Console.WriteLine($"  {OverlayState.GetActivePeriodicPointsProgressBarGuid()}");
                var resumeDelay = GetUpdateDelayMilliseconds();
                Console.WriteLine($"  resumeDelay = {resumeDelay}");
                _updateTimer = new Timer(HandleUpdateTimerTick, _autoEvent, resumeDelay, _updateTimerPeriod);
            }
        }
    }

    #endregion Initialization

    #region Progress Bar Display
    private void SyncProgressState()
    {
        // Step 1: get controlling team Faction ID
        //_controllingTeamOrdinal = ScrimMatchEngine.GetFacilityControlTeamOrdinal();

        if (_controllingTeamOrdinal.HasValue)
        {
            _controllingFactionId = ScrimTeamsManager.GetTeam(_controllingTeamOrdinal.Value).FactionId;
        }
        else
        {
            _showComponent = false;
            InvokeAsyncStateHasChanged();
            return;
        }

        if (!_controllingFactionId.HasValue)
        {
            _showComponent = false;
            InvokeAsyncStateHasChanged();
            return;
        }
        else
        {
            _showComponent = true;
        }

        // Step 2: get progress towards next tick
        var millisecondsFromLastPeriodicTick = GetMillisecondsElapsedFromLastPeriodicTick();

        if (millisecondsFromLastPeriodicTick == Timeout.Infinite) // && MatchState != MatchState.Paused)
        {
            _scaleValue = 0;
            InvokeAsyncStateHasChanged();
            return;
        }

        var intervalMilliseconds = SecondsPerTick * 1000;
        var millisecondsRemaining = intervalMilliseconds - millisecondsFromLastPeriodicTick;

        if (millisecondsRemaining < 0)
        {
            millisecondsRemaining = 0;
        }

        _scaleValue = (millisecondsRemaining * 1.0) / intervalMilliseconds;

        InvokeAsyncStateHasChanged();



        //if (_latestPeriodicPointsTimerTickMessage == null)
        //{
        //    return;
        //}

        //var latestPeriodicTickTime = _latestPeriodicPointsTimerTickMessage.Timestamp;

        //var currentTime = DateTime.UtcNow;

        //_msSinceLastTick = (int)(DateTime.UtcNow - latestPeriodicTickTime).TotalMilliseconds;

        //var msTotal = SecondsPerTick * 1000;
        //var msRemaining = msTotal - _msSinceLastTick; //- 1000;

        //if (msRemaining < 0)
        //{
        //    msRemaining = 0;
        //}

        //_scaleValue = (msRemaining * 1.0) / msTotal;

        //InvokeAsyncStateHasChanged();
    }

    private int GetUpdateDelayMilliseconds()
    {
        Console.WriteLine($"  _lastUpdateTime (1): {_lastUpdateTime}");

        if (_latestPeriodicPointsTimerTickMessage == null)
        {
            return Timeout.Infinite;
        }

        var currentTime = DateTime.UtcNow;
        //var updateIntervalMilliseconds = 1000;

        if (!_lastUpdateTime.HasValue && !LastElapsedTime.HasValue)
        {
            return Timeout.Infinite;
        }
        else if (!_lastUpdateTime.HasValue && LastElapsedTime.HasValue)
        {
            var millisecondsFromLastElapsed = GetMillisecondsElapsedFromLastPeriodicTick();

            Console.WriteLine($"  millisecondsFromLastElapsed = {millisecondsFromLastElapsed}");

            var timeSpanRemainder = TimeSpan.FromMilliseconds(millisecondsFromLastElapsed % _updateTimerPeriod);

            _lastUpdateTime = currentTime.Subtract(timeSpanRemainder);
        }

        var lastState = _latestPeriodicPointsTimerTickMessage.State;

        // TODO: Do we need to check more states here?
        if (lastState == TimerState.Paused)
        {
            return Timeout.Infinite;
        }

        // Step 1: Current Time - Last Tick Time
        var millisecondsFromLastUpdateTick = (int)(currentTime - _lastUpdateTime.Value).TotalMilliseconds;

        // Step 2: Get pause delay, if there is one
        int pauseDelayMilliseconds = 0;

        if (LastPausedTime.HasValue && LastResumedTime.HasValue)
        {
            pauseDelayMilliseconds = (int)(LastResumedTime.Value - LastPausedTime.Value).TotalMilliseconds;
        }

        var updateDelayMilliseconds = _updateTimerPeriod - (millisecondsFromLastUpdateTick - pauseDelayMilliseconds);

        Console.WriteLine($"  _lastUpdateTime (2): {_lastUpdateTime}");
        Console.WriteLine($"  millisecondsFromLastUpdateTick = {millisecondsFromLastUpdateTick}");
        Console.WriteLine($"  pauseDelayMilliseconds = {pauseDelayMilliseconds}");
        Console.WriteLine($"  updateDelayMilliseconds = {updateDelayMilliseconds}");

        if (updateDelayMilliseconds < Timeout.Infinite || updateDelayMilliseconds > 1000)
        {
            updateDelayMilliseconds = 0;
        }

        return updateDelayMilliseconds;
    }

    private int GetMillisecondsElapsedFromLastPeriodicTick()
    {
        if (_latestPeriodicPointsTimerTickMessage == null)
        {
            return Timeout.Infinite;
        }

        if (!LastElapsedTime.HasValue)
        {
            return Timeout.Infinite;
        }

        // Step 1: Current Time - Last Elapsed Tick Time
        var currentTime = DateTime.UtcNow;

        var millisecondsFromLastElapsedTick = (int)(currentTime - LastElapsedTime.Value).TotalMilliseconds;

        // Step 2: Get pause delay, if there was one
        int pauseDelayMilliseconds = 0;

        if (LastPausedTime.HasValue && LastResumedTime.HasValue)
        {
            pauseDelayMilliseconds = (int)(LastResumedTime.Value - LastPausedTime.Value).TotalMilliseconds;
        }
        else if (LastPausedTime.HasValue && !LastResumedTime.HasValue)
        {
            pauseDelayMilliseconds = (int)(currentTime - LastPausedTime.Value).TotalMilliseconds;
        }

        var intervalMilliseconds = SecondsPerTick * 1000;

        var millisecondsElapsed = (millisecondsFromLastElapsedTick - pauseDelayMilliseconds);

        return millisecondsElapsed;

    }

    #endregion Progress Bar Display

    #region Event Handling
    //private void ReceiveMatchTimerTickEvent(object sender, ScrimMessageEventArgs<MatchTimerTickMessage> e)
    //{
    //    var message = e.Message;
    //}

    private void ReceivePeriodicPointsTimerTickEvent(object sender, ScrimMessageEventArgs<PeriodicPointsTimerStateMessage> e)
    {
        Console.WriteLine($"======= ReceivePeriodicPointsTimerTickEvent ({_instanceGuid})  =======");
        Console.WriteLine($"  {OverlayState.GetActivePeriodicPointsProgressBarGuid()}");
        //_periodicMsgLock.WaitAsync(e.Message.Guid.ToString());
        //_periodicMsgLock?.Wait();
        _msgAutoEvent.WaitOne();
        Console.WriteLine($"  InstanceID: {_instanceGuid}");
        Console.WriteLine($"  Message GUID: {e.Message.Guid}");
        Console.WriteLine($"  _disposed: {_disposed}");

        if (_instanceGuid != OverlayState.GetActivePeriodicPointsProgressBarGuid())
        {
            Console.WriteLine($"  Discarded periodic tick message for mismatched component GUID");
            _updateTimer?.Dispose();

            MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
            MessageService.RaiseScrimFacilityControlActionEvent -= ReceiveFacilityControlEvent;
            MessageService.RaiseMatchStateUpdateEvent -= ReceiveMatchStateUpdateEvent;

            _msgAutoEvent.Set();
            //_periodicMsgLock?.Release();

            return;
        }


        if (_disposed)
        {
            Console.WriteLine($"  Discarded periodic tick message for disposed component");
            //MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
            _msgAutoEvent.Set();
            //_periodicMsgLock?.Release();
            return;
        }

        var message = e.Message;
        //Console.WriteLine($"  Message GUID: {message.Guid}");

        if (_latestPeriodicPointsTimerTickMessage != null && message.Guid == _latestPeriodicPointsTimerTickMessage.Guid)
        {
            Console.WriteLine($"  Discarded duplicate periodic tick message (1)");
            //MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
            _msgAutoEvent.Set();
            //_periodicMsgLock?.Release();
            return;
        }

        if (lastReceivedGuid == message.Guid)
        {
            Console.WriteLine($"  Discarded duplicate periodic tick message (2)");
            //MessageService.RaisePeriodicPointsTimerTickEvent -= ReceivePeriodicPointsTimerTickEvent;
            _msgAutoEvent.Set();
            //_periodicMsgLock?.Release();
            return;
        }

        lastReceivedGuid = message.Guid;

        var latestTickTime = (_latestPeriodicPointsTimerTickMessage == null) ? DateTime.UtcNow : _latestPeriodicPointsTimerTickMessage.Timestamp;
        var latestElapsedTime = (_latestPeriodicPointsTimerTickMessage == null) ? DateTime.UtcNow : _latestPeriodicPointsTimerTickMessage.LastElapsedTime;
        var latestState = (_latestPeriodicPointsTimerTickMessage == null) ? TimerState.Uninitialized : _latestPeriodicPointsTimerTickMessage.State;
        bool? latestElapsed = (_latestPeriodicPointsTimerTickMessage == null) ? (bool?)null : _latestPeriodicPointsTimerTickMessage.PeriodElapsed;
        var newState = message.State;

        //if (message.PeriodElapsed)
        //{
        //    _latestElapsedPeriodicPointsTimerTickMessage = message;
        //}

        _latestPeriodicPointsTimerTickMessage = message;

        //Console.WriteLine($"Received Periodic Points timer Tick Event: {Enum.GetName(typeof(TimerState), latestState)} => {Enum.GetName(typeof(TimerState), newState)}");
        Console.WriteLine($"  Periodic TimerState: {Enum.GetName(typeof(TimerState), latestState)} => {Enum.GetName(typeof(TimerState), newState)}");
        Console.WriteLine($"  Periodic ElapsedTime: {latestElapsedTime} => {message.LastElapsedTime}");
        Console.WriteLine($"  Periodic PeriodElapsed?: {latestElapsed} => {message.PeriodElapsed}");

        var resumeDelay = 0;

        if (!message.PeriodElapsed)
        {
            resumeDelay = GetUpdateDelayMilliseconds();
        }

        Console.WriteLine($"  resumeDelay: {resumeDelay}");

        _updateTimer.Change(resumeDelay, _updateTimerPeriod);

        //// Resuming. TODO: fix this behavior
        //if (newState == TimerState.Running && latestState == TimerState.Paused)
        //{
        //    //var msSinceLastTick = (int)(DateTime.UtcNow - latestTickTime).TotalMilliseconds;

        //    //var resumeDelay = 1000 - (msSinceLastTick % 1000);

        //    //if (resumeDelay < 0)
        //    //{
        //    //    resumeDelay = 0;
        //    //}

        //    var resumeDelay = GetUpdateDelayMilliseconds();

        //    _updateTimer.Change(resumeDelay, 1000);

        //    //_updateTimer.Change(_resumeDelayMs, 1000);
        //}
        //// Other timer start
        //else if (newState == TimerState.Running)
        //{
        //    _updateTimer.Change(0, 1000);
        //    // TODO: clear the pause-tracking variables
        //}
        //else if (newState == TimerState.Paused)
        //{
        //    _updateTimer.Change(Timeout.Infinite, 1000);

        //    //_resumeDelayMs = (int)(DateTime.UtcNow - _lastUpdateTime).TotalMilliseconds;
        //}
        //else if (newState == TimerState.Stopped)
        //{
        //    _updateTimer.Change(Timeout.Infinite, 1000);
        //    // TODO: clear the pause-tracking variables
        //}

        //SyncProgressState();
        _msgAutoEvent.Set();
        //_periodicMsgLock?.Release();
    }

    private void ReceiveFacilityControlEvent(object sender, ScrimMessageEventArgs<ScrimFacilityControlActionEventMessage> e)
    {
        Console.WriteLine($"======= ReceiveFacilityControlEvent ({_instanceGuid})  =======");
        Console.WriteLine($"  {OverlayState.GetActivePeriodicPointsProgressBarGuid()}");
        var stateChanged = false;

        var message = e.Message;

        var newControllingTeamOrdinal = message.FacilityControl.ControllingTeamOrdinal;

        if (!_controllingTeamOrdinal.HasValue)
        {
            _controllingTeamOrdinal = newControllingTeamOrdinal;
            stateChanged = true;
        }
        else if (newControllingTeamOrdinal != _controllingTeamOrdinal.Value)
        {
            _controllingTeamOrdinal = newControllingTeamOrdinal;
            stateChanged = true;
        }

        if (stateChanged)
        {
            _latestFacilityControlMessage = message;
            _controllingFactionId = ScrimTeamsManager.GetTeam(_controllingTeamOrdinal.Value).FactionId;

            //_updateTimer.Start();
            //_updateTimer.Change(1000, 1000);

            SyncProgressState();
            //InvokeAsyncStateHasChanged();
        }
    }

    //private void ReceiveMatchConfigurationUpdateEvent(object sender, ScrimMessageEventArgs<MatchConfigurationUpdateMessage> e)
    //{
    //    var message = e.Message;
    //}

    //private void ReceiveMatchStateUpdateEvent(object sender, ScrimMessageEventArgs<MatchStateUpdateMessage> e)
    //{
    //    var message = e.Message;
    //}

    private void ReceiveMatchStateUpdateEvent(object sender, ScrimMessageEventArgs<MatchStateUpdateMessage> e)
    {
        var message = e.Message;

        var oldMatchState = MatchState;
        var newMatchState = message.MatchState;

        if (oldMatchState != newMatchState)
        {
            MatchState = newMatchState;

            //SyncMatchAndTeamState();
            SyncMatchStateAndConfig();

            InvokeAsyncStateHasChanged();
        }
    }

    #endregion Event Handling

    #region Update Timer
    private void HandleUpdateTimerTick(object state)
    {
        _lastUpdateTime = DateTime.UtcNow;

        SyncProgressState();
    }

    #endregion Update Timer

    private void InvokeAsyncStateHasChanged()
    {
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }
}
